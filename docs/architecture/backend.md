# Backend Architecture: Core Simulation and Services

## Overview
The core backend domain in FBA-Bench handles the simulation framework for e-commerce benchmarking, focusing on event-driven state management, service orchestration, and metrics computation. It provides the foundational logic for running deterministic simulations of agent interactions in a virtual marketplace, including product pricing, sales processing, inventory tracking, and performance evaluation. Boundaries are clearly defined: the core backend manages internal simulation state and events without direct external I/O, while the API layer (in src/fba_bench_api/) exposes endpoints for initiating simulations, querying results, and integrating with persistence (e.g., database, Redis). The core does not handle HTTP routing or authentication; it integrates via dependency injection in the API's container, ensuring loose coupling where the API resolves and starts core services like the event bus and orchestrator during lifespan events.

## Modules and Responsibilities
- src/fba_bench_core/: Central package for simulation logic, encapsulating models, utilities, and services. It defines canonical types (e.g., financial calculations via money.py), configuration (config.py for environment-driven settings), logging (logging.py for structured output), and events (events.py for base event schemas like SaleProcessedEvent).
- src/fba_bench_core/event_bus.py: Compatibility layer for event publishing and subscription, bridging to the underlying fba_events.bus for in-memory or distributed dispatching. Manages singleton access via get_event_bus() for runtime coordination.
- src/fba_bench_core/services/: Subpackage for domain-specific services handling simulation aspects like sales (sales_service.py processes tick-driven demand), supply chain (supply_chain_service.py manages procurement), competitor analysis (competitor_manager.py tracks market rivals), and trust scoring (trust_score_service.py evaluates entity reliability). Includes world_store/ for centralized state persistence and arbitration.
- src/fba_bench_core/simulation_orchestrator.py: Coordinates the simulation lifecycle by generating timed TickEvent publications to drive service interactions, configurable via SimulationConfig for intervals, limits, and acceleration.
- Supporting modules: metrics.py re-exports aggregation logic for performance scoring; cli.py provides entry points for running simulations outside the API.

## Event and Interaction Model
Components interact via a publish-subscribe pattern over the event bus, promoting decoupling and scalability. Publishers (e.g., orchestrator for ticks, services for domain events like sales or price updates) dispatch typed events without direct knowledge of subscribers. Subscribers (e.g., sales service listening for ticks, world store for commands) register handlers that process events asynchronously, updating internal state and potentially publishing follow-on events. This model ensures unidirectional data flow: state changes propagate as events, with the world store acting as the authoritative coordinator to resolve conflicts before broadcasting updates. Runtime creation occurs via singleton access in the API container, with services starting handlers during lifespan initialization.

## Simulation Flow Narrative
The simulation begins with the API resolving and starting the event bus and orchestrator. The orchestrator enters a loop, publishing a TickEvent at configurable intervals to signal time progression. Services subscribed to ticks react by evaluating state: for instance, the sales service computes demand based on current market conditions and publishes SaleOccurred events if sales occur. Agent commands (e.g., price adjustments) route through the world store for arbitration, which resolves conflicts and publishes authoritative updates like price changes. Other services, such as trust scoring or supply chain, subscribe to these updates to adjust metrics or inventory. The loop continues until a tick limit is reached or stopped explicitly, with metrics aggregating across events for final evaluation. Periodic snapshots ensure state recovery across restarts.

## Service Boundaries and Duplicates
The src/fba_bench_core/services/ subpackage defines the primary, canonical implementations for all core services, including sales_service.py for revenue simulation, supply_chain_service.py for logistics, and world_store/ for state management. In contrast, src/services/ serves as a deprecated shim, importing and re-exporting everything from services/ while issuing a DeprecationWarning on use. This creates mirrored modules (e.g., src/services/sales_service.py imports from the core version; src/services/world_store.py imports from core's world_store subpackage), leading to redundant paths without functional divergence—both trees point to the same logic. Both are active in legacy code paths, but the shim ensures backward compatibility. Proposed consolidation: Remove src/services/ entirely in Phase 1, updating all imports to src/fba_bench_core/services/ via a global find-replace and mypy strict checks. Retain a single __init__.py in core/services/ for convenient wildcard imports, and add py.typed stubs if needed for type checkers.

## Risks and Recommended Refactors
- Duplicate module trees (src/services/ vs. src/fba_bench_core/services/): Risks maintenance overhead and import confusion in mixed codebases. Mitigation: Audit import usage with search_files for "from services import", then apply bulk replacement to core paths; enforce via pre-commit hook checking for deprecated imports.
- Potential cyclic dependencies between orchestrator and services: The orchestrator publishes ticks that services consume, but services may indirectly influence orchestration via events—tight coupling could block independent testing. Mitigation: Introduce an abstraction layer (e.g., ITickPublisher interface) for the orchestrator, allowing mocked ticks in unit tests; verify acyclic imports with mypy --namespace-packages.
- Unclear interfaces in world_store/: Direct state mutation helpers (e.g., set_product_state) expose internals, risking bypass of arbitration in tests or future code. Mitigation: Deprecate mutation helpers, routing all changes through event-based commands; add integration tests enforcing event-driven updates only.
- Areas lacking tests: Core events.py and metrics.py have minimal coverage, with no fixtures for event validation; orchestrator lacks edge-case tests for acceleration and limits. Mitigation: Add pytest markers for unit/integration in tests/contracts/, targeting 90% coverage on these modules via make test-contracts; prioritize orchestrator tick generation and service subscriptions.
- Hard-coded backends in event_bus.py: Compatibility shims assume in-memory defaults, limiting distributed testing without reconfiguration. Mitigation: Expose backend selection via config.py (e.g., EVENT_BUS_BACKEND env var), defaulting to in-memory but supporting asyncio/distributed; update CI to validate both modes.

## Next Steps
- Achieve Phase 0 coverage: Run make test-all to baseline current metrics, then add targeted tests for orchestrator (tick sequencing) and metrics (event aggregation) to hit 85% on core modules.
- Dependency cleanups: Use poetry update to pin versions, then audit cyclic imports with mypy strict; remove src/services/ shims post-import migration.
- CI gates: Enhance .github/workflows/ci.yml with ruff check on src/fba_bench_core/ and a new contract test step for event bus publish/subscribe roundtrips.
- Bifurcation prep: Document API-core boundaries in a separate ADR, ensuring container wiring supports independent core runs for offline simulation validation.
