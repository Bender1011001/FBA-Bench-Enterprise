<![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<tool_usage_guide>
  <overview>
    Guidelines for using tools in the FBA CLI Agent mode. Prioritize tools that enable safe, informed execution
    of project operations. Always use one tool per message, wait for results, and adapt based on output.
    Focus on execute_command for CLI actions, read tools for context, and edit tools for configs/scripts only.
  </overview>

  <tool_priorities>
    <priority level="1">
      <tool>codebase_search</tool>
      <when>Initial exploration of code or features (e.g., "how does billing work?").</when>
      <why>Semantic search across workspace finds relevant files (api/, src/services/) without exact keywords; essential for understanding simulations/red-team/infra.</why>
    </priority>

    <priority level="2">
      <tool>read_file</tool>
      <when>After search identifies files; inspect configs (e.g., .env, docker-compose.yml), logs, or outputs (e.g., tf plan).</when>
      <why>Provides exact content with line numbers for diffs or verification; limit to 5 files max, prioritize critical (e.g., README.md, pyproject.toml).</why>
    </priority>

    <priority level="3">
      <tool>execute_command</tool>
      <when>Main action: Run CLI (pip, uvicorn, pytest, terraform, docker); always after context gathering.</when>
      <why>Executes project ops in workspace dir; use for all commands, chain with &&/cd, handle Windows cmd.exe syntax.</why>
    </priority>

    <priority level="4">
      <tool>ask_followup_question</tool>
      <when>Ambiguous requests (e.g., tenant name, confirm destructive); 2-4 actionable suggests.</when>
      <why>Gathers details without assumptions; e.g., suggests: "demo tenant", "acme tenant", "custom name".</why>
    </priority>

    <priority level="5">
      <tool>apply_diff / write_to_file</tool>
      <when>Safe edits (configs/scripts/tests); read first for diff.</when>
      <why>Targeted changes; restricted to .env.example, scripts/, tests/; full content for new files, no secrets.</why>
    </priority>
  </tool_priorities>

  <tool_specific_guidance>
    <tool name="execute_command">
      <purpose>Run shell commands in workspace (cmd.exe on Windows); core for CLI interactions like start server, tests, provision.</purpose>
      <when_to_use>Any operational task: install, run API/UI, migrate DB, docker up, terraform plan/apply, pytest, npm dev/test.</when_to_use>
      <syntax>
        <command>execute_command</command>
        <parameters>
          <parameter name="command" required="true">
            <description>Full command string; use quotes for args with spaces, chain with && (e.g., "cd web && npm run dev").</description>
            <type>string</type>
            <example>"uvicorn api.server:app --reload --host 0.0.0.0 --port 8000"</example>
          </parameter>
          <parameter name="cwd" required="false">
            <description>Optional subdir (default workspace root); but prefer cd in command for consistency.</description>
            <type>string</type>
            <example>"infrastructure/terraform"</example>
          </parameter>
        </parameters>
      </syntax>
      <best_practices>
        <practice>Prepend cd for subdirs (e.g., "cd web && npm i"); handle OS (PowerShell .ps1 on Windows).</practice>
        <practice>Verify prereqs first (e.g., read_file package.json before npm).</practice>
        <practice>For infra: Always plan before apply; use --dry-run where avail.</practice>
        <practice>Parse output: Look for success (e.g., "Server running"), errors (stderr), suggest fixes.</practice>
      </best_practices>
      <examples>
        <example scenario="start backend">
          <code><![CDATA[<execute_command>
<command>uvicorn api.server:app --reload --host 0.0.0.0 --port 8000</command>
</execute_command>]]></code>
          <output>Expected: "Uvicorn running on http://0.0.0.0:8000"; if error: "Module not found" → suggest install.</output>
        </example>

        <example scenario="run pytest">
          <code><![CDATA[<execute_command>
<command>pytest tests/test_auth_login.py -q</command>
</execute_command>]]></code>
          <output>Expected: Test results (passed/failed); coverage if --cov.</output>
        </example>

        <example scenario="provision dry-run">
          <code><![CDATA[<execute_command>
<command>cd infrastructure/scripts && provision_demo_tenant.ps1 -Tenant demo</command>
</execute_command>]]></code>
          <output>Expected: "Plan generated in tenants/demo/"; no apply.</output>
        </example>
      </examples>
    </tool>

    <tool name="read_file">
      <purpose>Read file contents (line-numbered) for inspection/verification.</purpose>
      <when_to_use>Check configs (.env, docker-compose.yml), logs (after command), code (before edit), docs (README.md).</when_to_use>
      <syntax>
        <command>read_file</command>
        <parameters>
          <parameter name="args" required="true">
            <description>One or more <file><path>file.py</path></file>; max 5.</description>
            <type>list of file elements</type>
            <example><args><file><path>.env.example</path></file><file><path>pyproject.toml</path></file></args></example>
          </parameter>
        </parameters>
      </syntax>
      <best_practices>
        <practice>Batch related files (e.g., all docker-compose.*.yml).</practice>
        <practice>Use for pre-execution: Read .env before edit, README for usage.</practice>
        <practice>Handle binary/non-text: Avoid PDFs; stick to .py/.yml/.json/.md.</practice>
      </best_practices>
      <examples>
        <example scenario="check env vars">
          <code><![CDATA[<read_file>
<args>
  <file><path>.env.example</path></file>
</args>
</read_file>]]></code>
          <output>Lines with DATABASE_URL, JWT_SECRET, etc.; suggest copy/edit.</output>
        </example>

        <example scenario="inspect scripts">
          <code><![CDATA[<read_file>
<args>
  <file><path>infrastructure/scripts/provision_demo_tenant.ps1</path></file>
  <file><path>infrastructure/scripts/generate_tenant_configs.py</path></file>
</args>
</read_file>]]></code>
          <output>Script contents; verify params like --tenant.</output>
        </example>
      </examples>
    </tool>

    <tool name="apply_diff">
      <purpose>Surgical edits to existing files (search/replace blocks).</purpose>
      <when_to_use>Update configs (.env.example → .env), scripts (add flags), tests; read first for exact match.</when_to_use>
      <syntax>
        <command>apply_diff</command>
        <parameters>
          <parameter name="path" required="true">
            <description>File path relative to workspace.</description>
            <type>string</type>
            <example>scripts/smoke_user_store.py</example>
          </parameter>
          <parameter name="diff" required="true">
            <description>One or more SEARCH/REPLACE blocks with :start_line:.</description>
            <type>string (multi-block)</type>
            <example>See below.</example>
          </parameter>
        </parameters>
      </syntax>
      <best_practices>
        <practice>Read file first (read_file) for exact SEARCH content/whitespace.</practice>
        <practice>Multiple blocks in one call for efficiency; include line nums.</practice>
        <practice>Restricted: Only .env.example, scripts/, tests/, infrastructure/scripts/; no core code.</practice>
        <practice>Backup: Suggest read_file before/after for diff.</practice>
      </best_practices>
      <examples>
        <example scenario="update .env for Stripe">
          <code><![CDATA[<apply_diff>
<path>.env</path>
<diff>
<<<<<<< SEARCH
:start_line:5
-------
# STRIPE_SECRET_KEY=sk_test_your_key_here
=======
STRIPE_SECRET_KEY=sk_test_1234567890abcdef
>>>>>>> REPLACE
</diff>
</apply_diff>]]></code>
          <output>Applied; verify with read_file .env.</output>
        </example>
      </examples>
    </tool>

    <tool name="ask_followup_question">
      <purpose>Clarify ambiguous requests with 2-4 specific suggestions.</purpose>
      <when_to_use>Unclear params (e.g., tenant name, confirm apply), missing details (e.g., test subset).</when_to_use>
      <syntax>
        <command>ask_followup_question</command>
        <parameters>
          <parameter name="question" required="true">
            <description>Clear, specific question.</description>
            <type>string</type>
            <example>"Which tenant to provision?"</example>
          </parameter>
          <parameter name="follow_up" required="true">
            <description>List of <suggest>actionable answers; optional mode="code".</description>
            <type>list of suggest</type>
            <example><suggest>demo tenant</suggest><suggest>acme tenant</suggest></example>
          </parameter>
        </parameters>
      </syntax>
      <best_practices>
        <practice>2-4 suggests: Complete, ordered by likelihood (e.g., defaults first).</practice>
        <practice>No placeholders; specific to project (e.g., "docker-compose.dev.yml", "docker-compose.full.yml").</practice>
        <practice>Use for safety: "Confirm terraform apply? (destructive)".</practice>
      </best_practices>
      <examples>
        <example scenario="clarify stack">
          <code><![CDATA[<ask_followup_question>
<question>Which Docker stack to start?</question>
<follow_up>
  <suggest>dev stack (docker-compose.dev.yml)</suggest>
  <suggest>full stack (docker-compose.full.yml)</suggest>
  <suggest>postgres only (docker-compose.postgres.yml)</suggest>
</follow_up>
</ask_followup_question>]]></code>
          <output>User selects → proceed with execute_command.</output>
        </example>
      </examples>
    </tool>

    <tool name="update_todo_list">
      <purpose>Track multi-step tasks (e.g., full setup).</purpose>
      <when_to_use>Complex workflows: provision (generate→plan→apply), demo flow.</when_to_use>
      <syntax>
        <command>update_todo_list</command>
        <parameters>
          <parameter name="todos" required="true">
            <description>Markdown checklist: [ ] pending, [x] done, [-] in progress; single-level.</description>
            <type>string (full list)</type>
            <example>[x] Install deps\n[-] Migrate DB\n[ ] Start API</example>
          </parameter>
        </parameters>
      </syntax>
      <best_practices>
        <practice>Update after each step; mark progress, add discovered tasks.</practice>
        <practice>Order: Logical sequence (setup→run→validate).</practice>
        <practice>Remove only irrelevant; keep unfinished.</practice>
      </best_practices>
      <examples>
        <example scenario="provision sequence">
          <code><![CDATA[<update_todo_list>
<todos>
[x] Generate configs
[-] Terraform plan
[ ] Apply (confirm)
</todos>
</update_todo_list>]]></code>
          <output>Tracks until complete.</output>
        </example>
      </examples>
    </tool>
  </tool_specific_guidance>

  <general_guidelines>
    <guideline>One tool/message: e.g., search → read → command → validate.</guideline>
    <guideline>Wait for results: Adapt (e.g., if command fails, parse error, suggest fix).</guideline>
    <guideline>No assumptions: Use read_file for state; ask for secrets/choices.</guideline>
    <guideline>Safety: Dry-runs (terraform plan, docker compose config), mocks (tests).</guideline>
  </general_guidelines>
</tool_usage_guide>]]>