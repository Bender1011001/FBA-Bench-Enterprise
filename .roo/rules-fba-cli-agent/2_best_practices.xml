<![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<best_practices>
  <general_principles>
    <principle priority="high">
      <name>Safety First in Executions</name>
      <description>Always prioritize non-destructive actions; confirm user intent for any potentially harmful operations like resource deletion or real API calls.</description>
      <rationale>Prevents accidental data loss, high costs (e.g., real Stripe charges), or infrastructure changes in a production-like environment.</rationale>
      <example>
        <scenario>User says "deploy tenant"—plan dry-run first, ask for confirmation before tf apply.</scenario>
        <good>Use execute_command with --dry-run or --plan; follow up with ask_followup_question: "Confirm apply? (y/n)".</good>
        <bad>Directly run terraform apply without preview.</bad>
      </example>
    </principle>

    <principle priority="high">
      <name>Project-Aware Command Construction</name>
      <description>Construct commands using full project knowledge: relative paths from workspace root, handle Windows/Bash cross-platform, prepend cd for subdirs.</description>
      <rationale>Ensures commands work in the fixed workspace (c:/Users/andre/OneDrive/Documents/repos/FBA-Bench-Enterprise-1); avoids path errors.</rationale>
      <example>
        <scenario>"Start frontend"—use cd web && npm run dev.</scenario>
        <good>execute_command: "cd web && npm install && npm run dev" (check if installed first via read_file package.json).</good>
        <bad>Assume current dir is web/—always specify.</bad>
      </example>
    </principle>

    <principle priority="medium">
      <name>Idempotency and State Awareness</name>
      <description>Prefer idempotent operations; check current state (e.g., if server running, don't restart) before executing.</description>
      <rationale>Reduces errors, improves efficiency; aligns with project patterns (e.g., smoke tests skip dups).</rationale>
      <example>
        <scenario>"Run migrations"—check if head applied via alembic current.</scenario>
        <good>execute_command: "alembic current"; if not head, then "alembic upgrade head".</good>
        <bad>Always run upgrade without check.</bad>
      </example>
    </principle>

    <principle priority="medium">
      <name>Environment Variable Handling</name>
      <description>Read .env.example as template; suggest edits via apply_diff; never hardcode secrets; use placeholders for tests.</description>
      <rationale>Protects sensitive data (JWT/Stripe); enables safe local/prod configs.</rationale>
      <example>
        <scenario>"Set up Stripe"—read .env, diff to add STRIPE_SECRET_KEY=sk_test_...</scenario>
        <good>apply_diff on .env with search for existing, replace with placeholder.</good>
        <bad>write_to_file full .env with real keys.</bad>
      </example>
    </principle>
  </general_principles>

  <code_conventions>
    <convention category="command_formatting">
      <rule>Use shell syntax appropriate for OS (cmd.exe on Windows); chain with && for sequencing; quote paths with spaces.</rule>
      <examples>
        <good>execute_command: "cd infrastructure/scripts && provision_demo_tenant.ps1 -Tenant demo" (PowerShell).</good>
        <bad>Assume bash on Windows: "cd infra && ./script.sh".</bad>
      </examples>
    </convention>

    <convention category="output_parsing">
      <rule>After execute_command, parse stdout/stderr for key info (e.g., port numbers, errors); summarize in response.</rule>
      <template>
        If output contains "Server running on http://0.0.0.0:8000", report: "API started at localhost:8000".
      </template>
    </convention>

    <convention category="nl_to_action_mapping">
      <rule>Map NL phrases to exact commands: "start API" → uvicorn; "test auth" → pytest tests/test_auth_*.py.</rule>
      <examples>
        <good>"Run smoke test" → python scripts/smoke_user_store.py.</good>
        <bad>Vague: execute_command without params.</bad>
      </examples>
    </convention>
  </code_conventions>

  <common_pitfalls>
    <pitfall>
      <description>Assuming tools/prereqs installed (e.g., poetry, terraform).</description>
      <why_problematic>Command fails with "not found"; wastes time.</why_problematic>
      <correct_approach>Check via execute_command "poetry --version"; suggest install if missing (e.g., "pip install poetry").</correct_approach>
    </pitfall>

    <pitfall>
      <description>Running destructive infra without dry-run (e.g., tf apply).</description>
      <why_problematic>Creates/deletes real resources, incurs costs.</why_problematic>
      <correct_approach>Always plan first: terraform plan; confirm via followup.</correct_approach>
    </pitfall>

    <pitfall>
      <description>Editing .env with real secrets in responses.</description>
      <why_problematic>Exposes keys in chat history.</why_problematic>
      <correct_approach>Use placeholders (sk_test_...); instruct user to set manually.</correct_approach>
    </pitfall>

    <pitfall>
      <description>Ignoring core dependency state (e.g., fba-bench-core not installed).</description>
      <why_problematic>Imports fail in sims/services.</why_problematic>
      <correct_approach>Smoke import: python -c "import fba_bench_core; print('OK')"; suggest pip install -e ../fba-bench-core.</correct_approach>
    </pitfall>
  </common_pitfalls>

  <quality_checklist>
    <category name="before_execution">
      <item>Confirm user intent with summary (e.g., "You want to start the API—confirm?").</item>
      <item>Verify env/prereqs via read_file/list_files.</item>
      <item>Plan multi-step with todo list.</item>
    </category>

    <category name="during_execution">
      <item>Use one tool per message; wait for result.</item>
      <item>Handle errors: Parse output, suggest fixes, retry safe.</item>
      <item>Log actions clearly (e.g., "Executing: cd web && npm run dev").</item>
    </category>

    <category name="after_execution">
      <item>Validate: Read outputs, check status (e.g., curl localhost:8000).</item>
      <item>Summarize results, next steps.</item>
      <item>Cleanup temps (e.g., docker down if requested).</item>
    </category>
  </quality_checklist>
</best_practices>]]>