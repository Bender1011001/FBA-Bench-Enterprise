import axios, { AxiosInstance, AxiosResponse, AxiosError } from 'axios';
import { toast } from 'react-hot-toast';

interface ApiResponse<T> {
  data: T;
  status: number;
}

class ApiService {
  private api: AxiosInstance;
  private ws: WebSocket | null = null;

  constructor(baseURL: string = 'http://localhost:8000') {
    this.api = axios.create({
      baseURL,
      headers: {
        'Content-Type': 'application/json',
      },
      timeout: 10000,
    });

    this.api.interceptors.response.use(
      (response: AxiosResponse) => response,
      (error: AxiosError) => {
        const url = error.config?.url;
        if (url && (url.includes('get_preferences') || url.includes('set_preferences'))) {
          console.error('Preferences API Error Details:', {
            status: error.response?.status,
            statusText: error.response?.statusText,
            url: url,
            method: error.config?.method,
            data: error.config?.data,
            headers: error.config?.headers,
            responseData: error.response?.data
          });
        }
        if (error.response?.status === 401) {
          toast.error('Session expired. Please refresh the page.');
        } else if ((error.response?.status ?? 0) >= 500) {
          toast.error('Server error. Please try again later.');
        }
        return Promise.reject(error);
      }
    );
  }

  async get<T>(endpoint: string, params?: Record<string, unknown>): Promise<ApiResponse<T>> {
    try {
      const response: AxiosResponse<T> = await this.api.get(endpoint, { params });
      return { data: response.data, status: response.status };
    } catch (error: unknown) {
      const axiosError = error as AxiosError;
      toast.error(`API request failed: ${axiosError.message}`);
      throw axiosError;
    }
  }

  async post<T>(endpoint: string, data?: Record<string, unknown>, config?: Record<string, unknown>): Promise<ApiResponse<T>> {
    try {
      const response: AxiosResponse<T> = await this.api.post(endpoint, data, config);
      return { data: response.data, status: response.status };
    } catch (error: unknown) {
      const axiosError = error as AxiosError;
      toast.error(`API request failed: ${axiosError.message}`);
      throw axiosError;
    }
  }

  async put<T>(endpoint: string, data?: Record<string, unknown>, config?: Record<string, unknown>): Promise<ApiResponse<T>> {
    try {
      const response: AxiosResponse<T> = await this.api.put(endpoint, data, config);
      return { data: response.data, status: response.status };
    } catch (error: unknown) {
      const axiosError = error as AxiosError;
      toast.error(`API request failed: ${axiosError.message}`);
      throw axiosError;
    }
  }

  async delete<T>(endpoint: string, config?: Record<string, unknown>): Promise<ApiResponse<T>> {
    try {
      const response: AxiosResponse<T> = await this.api.delete(endpoint, config);
      return { data: response.data, status: response.status };
    } catch (error: unknown) {
      const axiosError = error as AxiosError;
      toast.error(`API request failed: ${axiosError.message}`);
      throw axiosError;
    }
  }

  async checkHealth(): Promise<ApiResponse<{ status: string }>> {
    return this.get('/health');
  }

  async getClearMLStatus(): Promise<ApiResponse<{ connected: boolean }>> {
    return this.get('/clearml/status');
  }

  async getExperiments(project?: string): Promise<ApiResponse<Experiment[]>> {
    const params = project ? { project } : {};
    return this.get('/experiments', params);
  }

  async createExperiment(experiment: ExperimentCreateData): Promise<ApiResponse<Experiment>> {
    return this.post('/experiments', experiment as unknown as Record<string, unknown>);
  }

  async cloneExperiment(id: string, name: string): Promise<ApiResponse<Experiment>> {
    return this.post(`/experiments/${id}/clone`, { name });
  }

  async stopExperiment(id: string): Promise<ApiResponse<Experiment>> {
    return this.post(`/experiments/${id}/stop`);
  }

  async getSystemStats(): Promise<ApiResponse<SystemStats>> {
    return this.get('/system/stats');
  }

  async startClearMLStack(): Promise<ApiResponse<{ success: boolean }>> {
    return this.post('/clearml/start');
  }

  async checkEnvConfiguration(): Promise<ApiResponse<EnvCheckResponse>> {
    return this.get('/setup/env-check');
  }

  async updateConfiguration(config: ConfigUpdateRequest): Promise<ApiResponse<ConfigUpdateResponse>> {
    return this.post('/setup/update-config', config as unknown as Record<string, unknown>);
  }

  // WebSocket methods
  connectWebSocket(onMessage: (data: WebSocketMessage) => void, onError?: (error: Event) => void): void {
    try {
      this.ws = new WebSocket('ws://localhost:8000/ws');
      
      this.ws.onopen = () => {
        console.log('WebSocket connected');
      };

      this.ws.onmessage = (event) => {
        try {
          const data: WebSocketMessage = JSON.parse(event.data);
          onMessage(data);
        } catch (e) {
          console.error('Failed to parse WebSocket message:', e);
        }
      };

      this.ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        onError?.(error);
      };

      this.ws.onclose = () => {
        console.log('WebSocket disconnected');
      };
    } catch (error) {
      console.error('Failed to connect WebSocket:', error);
    }
  }

  disconnectWebSocket(): void {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }

  subscribe(event: string): void {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify({ action: 'subscribe', event }));
    }
  }

  unsubscribe(event: string): void {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify({ action: 'unsubscribe', event }));
    }
  }
}

// Type definitions for better type safety
interface Experiment {
  id: string;
  name: string;
  status: 'running' | 'completed' | 'failed' | 'queued';
  metrics?: {
    profit?: number;
    marketShare?: number;
    satisfaction?: number;
    score?: number;
  };
  progress?: number;
  tags?: string[];
  created: string;
  updated: string;
}

interface ExperimentCreateData {
  name: string;
  scenario: string;
  config: Record<string, unknown>;
}

interface SystemStats {
  experiments: {
    total: number;
    running: number;
    completed: number;
    failed: number;
  };
  performance: {
    avgScore: number;
    topScore: number;
    successRate: number;
  };
  resources: {
    cpuUsage: number;
    memoryUsage: number;
    activeWorkers: number;
  };
}

interface WebSocketMessage {
  type: string;
  data: unknown;
}

interface EnvCheckResponse {
  exists: boolean;
  valid: boolean;
  missing_keys: string[];
  required_keys: string[];
  environment?: string;
  auth_enabled?: boolean;
}

interface ConfigUpdateResponse {
  success: boolean;
  message: string;
  environment: string;
}

interface ConfigUpdateRequest {
  environment: string;
  auth_enabled: boolean;
  cors_origins: string;
  mongo_username: string;
  mongo_password: string;
  redis_password: string;
  clearml_access_key?: string;
  clearml_secret_key?: string;
}

export const apiService = new ApiService();
export const wsService = apiService;

export type { ApiResponse, Experiment, ExperimentCreateData, SystemStats, WebSocketMessage, EnvCheckResponse, ConfigUpdateResponse, ConfigUpdateRequest };

/**
 * ClearML Service for FBA-Bench Game Dashboard
 * 
 * Fetches data from ClearML REST API to power game-like UI elements:
 * - Quests: Experiments/tasks as missions with levels (tiers) and rewards (metrics).
 * - Stats: Real-time scalars as player attributes (e.g., Profit as Health, Market Share as Power).
 * - Leaderboard: Top tasks by composite score, with avatars (model icons).
 * 
 * API Base: Defaults to local ClearML API (http://localhost:8008).
 * Auth: Uses access_key/secret_key from env or prompt; for local, often not needed.
 * 
 * Usage:
 * - Initialize: new ClearMLService({ apiHost: 'http://localhost:8008' });
 * - Fetch quests: service.getQuests(project='FBA-Bench');
 * - Poll stats: service.getLiveStats(taskId);
 * 
 * Game Integration:
 * - Maps ClearML scalars to game stats with icons/colors.
 * - Adds animations-ready data (e.g., progress bars for objectives).
 * - Fallback to mock data if API unavailable for dev.
 */

interface ClearMLConfig {
  apiHost: string;
  accessKey?: string;
  secretKey?: string;
  project?: string;
}

interface Quest {
  id: string;
  name: string;
  status: 'active' | 'completed' | 'failed' | 'queued';
  level: number; // Difficulty tier as game level
  score: number; // Composite score
  rewards: string[]; // Met objectives as rewards
  progress: number; // 0-100% completion
  icon: string; // Lucide icon name
}

interface Stat {
  name: string;
  value: number;
  max: number;
  unit: string;
  icon: string; // Lucide icon
  color: string; // Tailwind class (e.g., 'text-blue-500')
  animation: 'pulse' | 'bounce' | 'none'; // For framer-motion
}

interface LeaderboardEntry {
  rank: number;
  player: string; // Model/agent name
  score: number;
  avatar: string; // Emoji or icon
  badge: string; // 'gold' | 'silver' | 'bronze'
}

export class ClearMLService {
  private apiHost: string;
  private accessKey: string | null;
  private secretKey: string | null;
  private project: string;
  private token: string | null = null; // For auth header

  constructor(config: ClearMLConfig) {
    this.apiHost = config.apiHost || 'http://localhost:8008';
    this.accessKey = config.accessKey || null;
    this.secretKey = config.secretKey || null;
    this.project = config.project || 'FBA-Bench';
    this.initializeAuth();
  }

  private async initializeAuth() {
    if (this.accessKey && this.secretKey) {
      // Generate token for API calls (ClearML uses basic auth or token)
      const response = await fetch(`${this.apiHost}/auth/login`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ access_key: this.accessKey, secret_key: this.secretKey }),
      });
      if (response.ok) {
        const data = await response.json();
        this.token = data.token;
      }
    }
  }

  private getAuthHeaders() {
    const headers = { 'Content-Type': 'application/json' };
    if (this.token) {
      headers['Authorization'] = `Bearer ${this.token}`;
    } else if (this.accessKey && this.secretKey) {
      // Fallback to basic auth
      const creds = btoa(`${this.accessKey}:${this.secretKey}`);
      headers['Authorization'] = `Basic ${creds}`;
    }
    return headers;
  }

  async getQuests(): Promise<Quest[]> {
    try {
      const response = await fetch(`${this.apiHost}/projects/${encodeURIComponent(this.project)}/experiments`, {
        headers: this.getAuthHeaders(),
      });
      if (!response.ok) throw new Error(`API error: ${response.status}`);
      const experiments = await response.json();

      return experiments.map((exp: any) => ({
        id: exp.id,
        name: exp.name,
        status: exp.status as Quest['status'],
        level: parseInt(exp.tags?.tier || '0'),
        score: exp.metrics?.composite_score || 0,
        rewards: exp.metrics?.rewards || [],
        progress: Math.min(100, (exp.iteration / exp.total_iterations) * 100 || 0),
        icon: 'zap', // Default; map based on type
      }));
    } catch (error) {
      console.warn('ClearML quests fetch failed, using mock:', error);
      // Mock for dev
      return [
        { id: '1', name: 'Smoke Test Quest', status: 'completed', level: 1, score: 95, rewards: ['Profit Achieved'], progress: 100, icon: 'check-circle' },
        { id: '2', name: 'Supply Chain Challenge', status: 'active', level: 2, score: 0, rewards: [], progress: 40, icon: 'truck' },
      ];
    }
  }

  async getLiveStats(taskId: string): Promise<Stat[]> {
    try {
      const response = await fetch(`${this.apiHost}/experiments/${taskId}/scalars`, {
        headers: this.getAuthHeaders(),
      });
      if (!response.ok) throw new Error(`API error: ${response.status}`);
      const scalars = await response.json();

      // Map to game stats
      return [
        { name: 'Profit', value: scalars.profit?.latest || 0, max: 100000, unit: 'USD', icon: 'dollar-sign', color: 'text-green-500', animation: 'pulse' },
        { name: 'Market Share', value: (scalars.market_share?.latest || 0) * 100, max: 100, unit: '%', icon: 'bar-chart-3', color: 'text-blue-500', animation: 'none' },
        { name: 'Delivery Rate', value: (scalars.on_time_delivery_rate?.latest || 0) * 100, max: 100, unit: '%', icon: 'package', color: 'text-yellow-500', animation: 'bounce' },
        { name: 'Satisfaction', value: (scalars.customer_satisfaction?.latest || 0) * 100, max: 100, unit: '%', icon: 'smile', color: 'text-purple-500', animation: 'none' },
      ];
    } catch (error) {
      console.warn('ClearML stats fetch failed, using mock:', error);
      return [
        { name: 'Profit', value: 10500, max: 100000, unit: 'USD', icon: 'dollar-sign', color: 'text-green-500', animation: 'pulse' },
        { name: 'Market Share', value: 15, max: 100, unit: '%', icon: 'bar-chart-3', color: 'text-blue-500', animation: 'none' },
      ];
    }
  }

  async getLeaderboard(): Promise<LeaderboardEntry[]> {
    try {
      const response = await fetch(`${this.apiHost}/projects/${encodeURIComponent(this.project)}/experiments?order_by=-metrics.composite_score`, {
        headers: this.getAuthHeaders(),
      });
      if (!response.ok) throw new Error(`API error: ${response.status}`);
      const experiments = await response.json();

      return experiments.slice(0, 10).map((exp: any, index: number) => ({
        rank: index + 1,
        player: exp.name.split('-')[0] || 'Agent', // Extract model name
        score: exp.metrics?.composite_score || 0,
        avatar: 'ðŸ¤–', // Default; map to model icon
        badge: index === 0 ? 'gold' : index === 1 ? 'silver' : index === 2 ? 'bronze' : 'default',
      }));
    } catch (error) {
      console.warn('ClearML leaderboard fetch failed, using mock:', error);
      return [
        { rank: 1, player: 'GPT-4o', score: 95, avatar: 'ðŸ§ ', badge: 'gold' },
        { rank: 2, player: 'Claude 3.5', score: 82, avatar: 'âš¡', badge: 'silver' },
        { rank: 3, player: 'Baseline Bot', score: 65, avatar: 'ðŸ¤–', badge: 'bronze' },
      ];
    }
  }

  // Poll for live updates (for real-time game feel)
  async pollUpdates(taskId: string, callback: (stats: Stat[]) => void, interval = 2000) {
    const intervalId = setInterval(async () => {
      const stats = await this.getLiveStats(taskId);
      callback(stats);
    }, interval);

    return () => clearInterval(intervalId);
  }
}

// Global instance for easy access
export const clearmlService = new ClearMLService({
  apiHost: import.meta.env.VITE_CLEARML_API_HOST || 'http://localhost:8008',
  accessKey: import.meta.env.VITE_CLEARML_ACCESS_KEY || '',
  secretKey: import.meta.env.VITE_CLEARML_SECRET_KEY || '',
  project: 'FBA-Bench',
});
/**
 * Centralized environment-aware configuration for frontend networking.
 * Supports both CRA (process.env.REACT_APP_*) and Vite (import.meta.env.VITE_*).
 * Defaults to same-origin for production safety when no env vars are provided.
 */

type ViteEnv = { [key: string]: string | undefined };

/** Safely read env from Vite or CRA */
function readEnv(viteKey: string, craKey: string): string | undefined {
  // Prefer Vite env at build time
  try {
    const viteEnv = (typeof import.meta !== 'undefined' && (import.meta as unknown as { env?: ViteEnv }).env) as ViteEnv | undefined;
    if (viteEnv && viteEnv[viteKey]) return viteEnv[viteKey];
  } catch {
    // ignore
  }
  // Fallback to CRA env
  try {
    if (typeof process !== 'undefined' && (process as unknown as { env?: Record<string, string | undefined> }).env) {
      const val = (process as unknown as { env?: Record<string, string | undefined> }).env![craKey];
      if (val) return val as string;
    }
  } catch {
    // ignore
  }
  return undefined;
}

// Return normalized API base URL (no trailing slash)
export function getApiBaseUrl(): string {
  const raw = (readEnv('VITE_API_URL', 'REACT_APP_API_URL') || '').trim();
  const base = raw || window.location.origin;
  return base.replace(/\/+$/, '');
}

// Return WebSocket URL. Uses env override or derives from current location.
export function getWebSocketUrl(): string {
  const raw = (readEnv('VITE_WS_URL', 'REACT_APP_WS_URL') || '').trim();
  if (raw) return raw;
  const isHttps = window.location.protocol === 'https:';
  const scheme = isHttps ? 'wss' : 'ws';
  return `${scheme}://${window.location.host}/ws`;
}

// Optional runtime validation; build-time validation happens in scripts/validate-env.cjs (when configured)
export function validateRuntimeEnv(): void {
  const api = (readEnv('VITE_API_URL', 'REACT_APP_API_URL') || '').trim();
  if (api && !/^https?:\/\//i.test(api)) {
    // Allow empty (same-origin), otherwise require absolute URL to avoid ambiguous bases
    // eslint-disable-next-line no-console
    console.warn('Invalid API URL. Expected absolute http(s) URL or empty for same-origin.');
  }
  const ws = (readEnv('VITE_WS_URL', 'REACT_APP_WS_URL') || '').trim();
  if (ws && !/^wss?:\/\//i.test(ws)) {
    // eslint-disable-next-line no-console
    console.warn('Invalid WS URL. Expected ws(s) URL or empty to derive from window.location.');
  }
}
import { RuntimeConfig, SettingsPayload, SettingsResponse } from 'types/api';
import { getApiBaseUrl } from './config';

type ErrorBody = { error?: string } | null | undefined;

/**
 * SettingsService - Runtime config and UI settings using Phase 1 endpoints.
 * Base URL follows config.ts: getApiBaseUrl() with same-origin default for production safety.
 */

const API_BASE_URL: string = getApiBaseUrl();


class SettingsAPIError extends Error {
  constructor(public status: number, public body: unknown, message?: string) {
    const b = body as ErrorBody;
    super(message || (b?.error ?? `HTTP ${status}`));
    this.name = 'SettingsAPIError';
  }
}

async function request<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
  const url = `${API_BASE_URL}${endpoint}`;
  const config: RequestInit = {
    headers: {
      'Content-Type': 'application/json',
      ...(options.headers || {}),
    },
    ...options,
  };

  try {
    const res = await fetch(url, config);
    const text = await res.text();
    const data = text ? JSON.parse(text) : null;

    if (!res.ok) {
      throw new SettingsAPIError(res.status, data, data?.error || res.statusText);
    }
    return data as T;
  } catch (err: unknown) {
    if (err instanceof SettingsAPIError) throw err;
    const message = err instanceof Error ? err.message : 'Unknown error';
    throw new SettingsAPIError(0, null, `Network error: ${message}`);
  }
}

// UI settings - GET /api/v1/settings
export async function getSettings(): Promise<SettingsResponse> {
  return request<SettingsResponse>('/api/v1/settings', { method: 'GET' });
}

// UI settings - POST /api/v1/settings
export async function postSettings(payload: SettingsPayload): Promise<SettingsResponse> {
  return request<SettingsResponse>('/api/v1/settings', {
    method: 'POST',
    body: JSON.stringify(payload ?? {}),
  });
}

// Runtime config - GET /api/v1/config
export async function getRuntimeConfig(): Promise<RuntimeConfig> {
  return request<RuntimeConfig>('/api/v1/config', { method: 'GET' });
}

// Runtime config - PATCH /api/v1/config
export async function patchRuntimeConfig(patch: RuntimeConfig): Promise<RuntimeConfig> {
  return request<RuntimeConfig>('/api/v1/config', {
    method: 'PATCH',
    body: JSON.stringify(patch ?? {}),
  });
}

export function isSettingsAPIError(e: unknown): e is SettingsAPIError {
  return e instanceof SettingsAPIError;
}

import { SimulationActionResponse, SimulationSnapshot, SimulationSpeedRequest } from 'types/api';
import { getApiBaseUrl } from './config';

type ErrorBody = { error?: string } | null | undefined;

/**
 * SimulationService - Orchestrator controls using Phase 1 endpoints.
 * Base URL uses config.ts getApiBaseUrl() with same-origin default for production safety.
 */

const API_BASE_URL: string = getApiBaseUrl();


class SimulationAPIError extends Error {
  constructor(public status: number, public body: unknown, message?: string) {
    const b = body as ErrorBody;
    super(message || (b?.error ?? `HTTP ${status}`));
    this.name = 'SimulationAPIError';
  }
}

async function request<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
  const url = `${API_BASE_URL}${endpoint}`;
  const config: RequestInit = {
    headers: {
      'Content-Type': 'application/json',
      ...(options.headers || {}),
    },
    ...options,
  };

  try {
    const res = await fetch(url, config);
    const text = await res.text();
    const data = text ? JSON.parse(text) : null;

    if (!res.ok) {
      throw new SimulationAPIError(res.status, data, data?.error || res.statusText);
    }
    return data as T;
  } catch (err: unknown) {
    if (err instanceof SimulationAPIError) throw err;
    const message = err instanceof Error ? err.message : 'Unknown error';
    throw new SimulationAPIError(0, null, `Network error: ${message}`);
  }
}

// POST /api/v1/simulation/start
export async function startSimulation(): Promise<SimulationActionResponse> {
  return request<SimulationActionResponse>('/api/v1/simulation/start', { method: 'POST' });
}

// POST /api/v1/simulation/stop
export async function stopSimulation(): Promise<SimulationActionResponse> {
  return request<SimulationActionResponse>('/api/v1/simulation/stop', { method: 'POST' });
}

// POST /api/v1/simulation/pause
export async function pauseSimulation(): Promise<SimulationActionResponse> {
  return request<SimulationActionResponse>('/api/v1/simulation/pause', { method: 'POST' });
}

// POST /api/v1/simulation/resume
export async function resumeSimulation(): Promise<SimulationActionResponse> {
  return request<SimulationActionResponse>('/api/v1/simulation/resume', { method: 'POST' });
}

// POST /api/v1/simulation/speed
export async function setSimulationSpeed(speed: number): Promise<SimulationActionResponse> {
  const payload: SimulationSpeedRequest = { speed };
  return request<SimulationActionResponse>('/api/v1/simulation/speed', {
    method: 'POST',
    body: JSON.stringify(payload),
  });
}

// GET /api/v1/simulation/snapshot
export async function getSimulationSnapshot(): Promise<SimulationSnapshot> {
  return request<SimulationSnapshot>('/api/v1/simulation/snapshot', { method: 'GET' });
}

export function isSimulationAPIError(e: unknown): e is SimulationAPIError {
  return e instanceof SimulationAPIError;
}

import { ClearMLStackStartRequest, ClearMLStackStartResponse, ClearMLStackStatus } from 'types/api';
import { getApiBaseUrl } from './config';

type ErrorBody = { error?: string } | null | undefined;

/**
 * StackService - ClearML stack controls using Phase 1 endpoints.
 * Uses config.ts getApiBaseUrl() with same-origin default for production safety.
 */

const API_BASE_URL: string = getApiBaseUrl();


class StackAPIError extends Error {
  constructor(public status: number, public body: unknown, message?: string) {
    const b = body as ErrorBody;
    super(message || (b?.error ?? `HTTP ${status}`));
    this.name = 'StackAPIError';
  }
}

async function request<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
  const url = `${API_BASE_URL}${endpoint}`;
  const config: RequestInit = {
    headers: {
      'Content-Type': 'application/json',
      ...(options.headers || {}),
    },
    ...options,
  };

  try {
    const res = await fetch(url, config);
    const text = await res.text();
    const data = text ? JSON.parse(text) : null;

    if (!res.ok) {
      throw new StackAPIError(res.status, data, data?.error || res.statusText);
    }
    return data as T;
  } catch (err: unknown) {
    if (err instanceof StackAPIError) throw err;
    const message = err instanceof Error ? err.message : 'Unknown error';
    throw new StackAPIError(0, null, `Network error: ${message}`);
  }
}

/**
 * POST /api/v1/stack/clearml/start
 */
export async function startClearMLStack(payload?: ClearMLStackStartRequest): Promise<ClearMLStackStartResponse> {
  return request<ClearMLStackStartResponse>('/api/v1/stack/clearml/start', {
    method: 'POST',
    body: JSON.stringify(payload ?? {}),
  });
}

/**
 * POST /api/v1/stack/clearml/stop
 */
export async function stopClearMLStack(): Promise<{ status?: string; message?: string } & Record<string, unknown>> {
  return request<{ status?: string; message?: string } & Record<string, unknown>>('/api/v1/stack/clearml/stop', {
    method: 'POST',
  });
}

/**
 * GET /api/v1/stack/clearml/status
 */
export async function getClearMLStackStatus(): Promise<ClearMLStackStatus> {
  return request<ClearMLStackStatus>('/api/v1/stack/clearml/status', { method: 'GET' });
}

/**
 * Utility to detect server-side gating (403 Disabled)
 */
export function isStackControlForbidden(error: unknown): boolean {
  return error instanceof StackAPIError && error.status === 403;
}

/**
 * Utility to format status safely for UI
 */
export function extractStackLinks(status: ClearMLStackStatus | null | undefined): {
  web?: string;
  api?: string;
  file?: string;
} {
  if (!status) return {};
  const { web_url, api_url, file_url } = status;
  return { web: web_url, api: api_url, file: file_url };
}

