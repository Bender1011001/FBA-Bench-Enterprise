The FBA-Bench Refactoring Master Guide
This document provides a detailed, phased plan to address the architectural, security, and quality issues within the FBA-Bench project. Each task includes specific file and line references to guide your team.

Phase 1: Triage and Stabilization (Immediate Priorities)
Goal: Close critical security holes and create a consistent, reliable development environment. This phase should be completed before any new feature development.

1. Remediate Hardcoded Secrets
Problem: The codebase contains hardcoded secrets, which is a severe security vulnerability. The JWT secret key in the enterprise repository is a prime example.

File: repos/fba-bench-enterprise/api/security/jwt.py
Lines: 10-12

Python

# Unsafe hardcoded secrets
SECRET_KEY = "your-super-secret-key-that-is-not-so-secret-anymore"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30
Instructions (Architect & DevOps Specialist):

Introduce pydantic-settings for centralized configuration management. Create a new file for this configuration.

Load all secrets and configuration variables from environment variables. Use .env files for local development.

Refactor the code to import and use the settings object instead of hardcoded values.

Ensure the .env file is listed in .gitignore to prevent accidental commits.

High-Level Code (repos/fba-bench-enterprise/api/config.py):

Python

# Create this new file
from pydantic_settings import BaseSettings, SettingsConfigDict
import os

class Settings(BaseSettings):
    # Load model from a .env file located in the root of the enterprise repo
    model_config = SettingsConfigDict(
        env_file=os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', '.env')), 
        extra='ignore'
    )

    # Security settings
    SECRET_KEY: str
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    
    # Add other configuration variables here as you refactor
    # e.g., DATABASE_URL: str

# Create a single, importable instance
settings = Settings()
Refactored Code (repos/fba-bench-enterprise/api/security/jwt.py):

Python

# Replace hardcoded values with the new settings object
from datetime import datetime, timedelta
from jose import JWTError, jwt
from ..config import settings # Import the new settings object

# Use the settings object for all configuration
SECRET_KEY = settings.SECRET_KEY
ALGORITHM = settings.ALGORITHM
ACCESS_TOKEN_EXPIRE_MINUTES = settings.ACCESS_TOKEN_EXPIRE_MINUTES

# ... rest of the file
2. Secure and Streamline the CI/CD Pipeline
Problem: The CI pipeline in .github/workflows/ci.yml has several critical issues. It allows security vulnerabilities to pass, and it runs redundant, conflicting linting and formatting jobs.

File: .github/workflows/ci.yml

Instructions (DevOps Specialist):

Enforce Security Scans: On line 103, change continue-on-error to false for the pip-audit job. A build with known vulnerabilities must fail.

Consolidate Linting and Formatting: Remove the separate black and ruff format steps (lines 62-68). Ruff can handle all of this. Replace them with a single, unified step.

High-Level Code (.github/workflows/ci.yml):

YAML

# ... (previous jobs)

  pip-audit:
    runs-on: ubuntu-latest
    continue-on-error: false # Changed from 'true' to 'false'
    steps:
      # ... (rest of the pip-audit job)

  test-and-lint:
    # ... (job setup)
    steps:
      # ... (checkout, setup, install steps)

      - name: Pre-commit checks (ruff, black, isort, misc)
        run: poetry run pre-commit run --all-files --show-diff-on-failure

      # CONSOLIDATE LINTING AND FORMATTING
      - name: Lint and Format Check with Ruff
        run: |
          poetry run ruff check .
          poetry run ruff format --check .

      # REMOVE THESE REDUNDANT STEPS
      # - name: Format check with Ruff
      #   run: poetry run ruff format --check .
      #
      # - name: Format check with Black
      #   run: poetry run black --check .

      # ... (rest of the steps: mypy, pytest, etc.)
Phase 2: Architectural Refactoring & Testing Overhaul
Goal: Eliminate code duplication, establish a clean and modular architecture, and build a comprehensive, reliable testing strategy.

1. Modularize the Codebase (Core vs. Enterprise)
Problem: The split_report.json shows massive code duplication between the fba-bench-core and fba-bench-enterprise repositories. This is unsustainable. The solution is to make fba-bench-core a proper, installable Python package.

Instructions (Architect):

Ensure repos/fba-bench-core is a valid Python package with a pyproject.toml that defines its structure.

In repos/fba-bench-enterprise/pyproject.toml, add fba-bench-core as a path-based, editable dependency. This allows the enterprise repo to use the core code as if it were a third-party library.

Go through the repos/split_report.json and for every file listed as "DUPLICATED", delete the copy from repos/fba-bench-enterprise.

Fix all resulting import errors in the enterprise repo by changing them to import from fba_bench_core.

High-Level Code (repos/fba-bench-enterprise/pyproject.toml):

Ini, TOML

[tool.poetry.dependencies]
python = "^3.9,<3.13"
fastapi = "^0.115.0"
# ... other enterprise dependencies

# Add this line to include the core library
fba-bench-core = {path = "../fba-bench-core", develop = true}

# ...
Example Import Refactoring:

Python

# In a file within repos/fba-bench-enterprise, for example:
# Old, broken import after deleting the duplicated file:
# from .services.some_core_service import some_function

# New, correct import from the core package:
from fba_bench_core.services.some_core_service import some_function 
2. Resurrect and Unify the Testing Strategy
Problem: The testing suite is incomplete and untrustworthy. End-to-end tests are disabled, and there are multiple, conflicting ways to run tests.

Instructions (QA Automation Engineer):

Enable End-to-End Tests:

File: tests/integration/test_end_to_end_scenarios.py

Action: Delete lines 3-7:

Python

pytest.skip(
    "Legacy React/TypeScript frontend removed; disabling E2E tests that depend on frontend services",
    allow_module_level=True,
)
Run the tests and fix all failures. This is non-trivial and will require debugging the entire workflow.

Unify Test Execution:

Problem: The CI (.github/workflows/ci.yml, lines 73-76) calls pytest directly, while a custom script (scripts/run_tests.py) also exists.

Action: Choose one method for running tests. The recommended approach is to use pytest directly and remove the scripts/run_tests.py script to eliminate confusion. Update all CI workflows to use the same, consistent pytest command.

Implement Frontend E2E Tests:

Problem: There are no end-to-end tests for the frontend, meaning user journeys are not being validated.

Action:

Choose a testing framework (Playwright is recommended for its speed and features).

Install it in the frontend directory: npm install -D @playwright/test.

Create a new test file, frontend/tests/e2e/onboarding.spec.ts, and write a test that simulates a user signing up and navigating the dashboard.

High-Level Code (frontend/tests/e2e/onboarding.spec.ts):

TypeScript

import { test, expect } from '@playwright/test';

test('should allow a user to sign up and see the dashboard', async ({ page }) => {
  await page.goto('http://localhost:5173');

  // Navigate to the registration page
  await page.click('a[href="#register"]');
  await expect(page).toHaveURL('http://localhost:5173/#register');

  // Fill out the registration form
  await page.fill('input[name="email"]', 'test@example.com');
  await page.fill('input[name="password"]', 'password123');
  await page.click('button[type="submit"]');

  // Verify that the user is redirected to the dashboard
  await expect(page).toHaveURL(/.*#dashboard/);
  await expect(page.locator('h1')).toContainText('Dashboard');
});
Phase 3: Code and Project Hygiene
Goal: Clean up the remaining technical debt to improve the developer experience and make future work easier and faster.

1. Decouple Frontend Content
Problem: The guided tour in the frontend (frontend/src/App.tsx) is hardcoded, making it difficult to update.

File: frontend/src/App.tsx
Lines: 345-420 (the steps array)

Instructions (Frontend Engineer):

Create a new file: frontend/src/config/tour-steps.json.

Cut the entire steps array from App.tsx and paste it into the new JSON file.

In App.tsx, import the JSON file and use it to populate the GuidedTour component.

High-Level Code (frontend/src/config/tour-steps.json):

JSON

[
  {
    "id": 0,
    "title": "Welcome to FBA-Bench",
    "description": "This guided tour will help you get started...",
    "target": ".logo-brand",
    "position": "bottom",
    "content": {
      "lines": [
        "You're now using the FBA-Bench platform for business agent simulation.",
        "Let's explore the main features."
      ]
    }
  },
  // ... all other steps
]
Refactored Code (frontend/src/App.tsx):

TypeScript

// Import the tour steps from the new JSON file
import tourSteps from './config/tour-steps.json';
import GuidedTour from './components/tour/GuidedTour';
// ... other imports

function App() {
  // ... other component logic

  return (
    // ...
    {showTour && (
      <GuidedTour
        isOpen={showTour}
        onClose={handleTourComplete}
        steps={tourSteps} // Use the imported JSON data
      />
    )}
    // ...
  );
}
2. Sanitize the Repository
Problem: The project is cluttered with temporary files, test artifacts, and redundant scripts.

Instructions (Architect & DevOps Specialist):

Delete Artifact Directories: Remove the following directories from version control:

fbadocs/

test_results/

perf_results/

scenario_results/

Clean Up Root Directory: Delete unused and one-off files from the root directory, such as:

find_bad_json.py

scan_json.py

test_openrouter_setup.py

tmp_auth_ws_validation.py

tmp_ws_redis_roundtrip.py

Update .gitignore: Add the deleted directories to your .gitignore file to prevent them from being committed again.

High-Level Code (.gitignore):

# Add these lines to the end of your .gitignore file

# Test and benchmark results
/fbadocs/
/test_results/
/perf_results/
/scenario_results/

# Temporary scripts
*.tmp
tmp_*.py
3. Consolidate and Secure Docker Configuration
Problem: The project has an excessive number of Docker-related files, and they run containers as the root user, which is a security risk.

Files: Dockerfile, Dockerfile.api, repos/fba-bench-enterprise/Dockerfile, etc.

Instructions (DevOps Specialist):

Consolidate Dockerfiles: Reduce the number of Dockerfiles. Aim for one for the backend and one for the frontend, using multi-stage builds for development and production.

Implement Non-Root User: In every Dockerfile, add instructions to create and use a non-root user.

High-Level Code (to be added to Dockerfile and Dockerfile.api):

Dockerfile

# ... (after installing dependencies)

# Create a non-root user and switch to it
RUN addgroup --system app && adduser --system --ingroup app app
USER app

# Set the entrypoint and command
CMD ["poetry", "run", "fba", "run", "test"]
By completing these three phases, your team will have addressed the most critical issues in the FBA-Bench project, transforming it into a secure, stable, and maintainable platform ready for future development.