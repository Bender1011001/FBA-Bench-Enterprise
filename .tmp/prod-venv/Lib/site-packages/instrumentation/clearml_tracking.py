from __future__ import annotations

"""
ClearMLTracker - Safe, optional ClearML integration for FBA-Bench.

- If ClearML is installed and configured, this wrapper initializes a ClearML Task,
  connects configuration, logs scalars each tick, and can upload artifacts.
- If ClearML is not installed or misconfigured, all methods degrade to no-ops so
  the simulation runs without additional dependencies.

Usage:
    from instrumentation.clearml_tracking import ClearMLTracker

    tracker = ClearMLTracker(project_name="FBA-Bench", task_name="Scenario_A", tags=["scenario"])
    tracker.connect({"scenario": "Scenario_A", "agent": "Dummy"})
    tracker.log_scalar("Profit", "USD", 123.45, iteration=1)
    tracker.log_parameters({"final_profit": 123.45})
    tracker.close()
"""

import json
from typing import Any, Dict, List, Optional

try:
    from clearml import Task  # type: ignore
    from clearml.logger import Logger  # type: ignore
except Exception:
    Task = None  # type: ignore[assignment]
    Logger = None  # type: ignore[assignment]


class _NoOpLogger:
    def report_scalar(self, *args, **kwargs) -> None:
        return

    def report_text(self, *args, **kwargs) -> None:
        return


class _NoOpTask:
    def connect(self, *_args, **_kwargs) -> None:
        return

    def get_logger(self) -> _NoOpLogger:
        return _NoOpLogger()

    def upload_artifact(self, *_args, **_kwargs) -> None:
        return

    def close(self) -> None:
        return


class ClearMLTracker:
    """
    Minimal, production-safe ClearML wrapper.

    - Does not raise if ClearML is absent; all methods become safe no-ops.
    - Avoids leaking exceptions from the underlying SDK.
    """

    def __init__(self, project_name: str, task_name: str, tags: Optional[List[str]] = None) -> None:
        self._enabled: bool = Task is not None
        self._task: Any
        self._logger: Any
        self._project_name = project_name
        self._task_name = task_name
        self._tags = tags or []

        if self._enabled:
            try:
                self._task = Task.init(
                    project_name=project_name, task_name=task_name, tags=self._tags
                )
                self._logger = self._task.get_logger()
            except Exception:
                # Fall back to no-op if initialization fails
                self._enabled = False
                self._task = _NoOpTask()
                self._logger = _NoOpLogger()
        else:
            self._task = _NoOpTask()
            self._logger = _NoOpLogger()

    def connect(self, config: Dict[str, Any]) -> None:
        """
        Attach configuration/parameters to the ClearML task (as read-only config).
        """
        try:
            self._task.connect(config or {})
        except Exception:
            # Silently ignore to keep simulation robust
            pass

    def log_scalar(
        self, title: str, series: str, value: float, iteration: Optional[int] = None
    ) -> None:
        """
        Report a scalar metric to ClearML.
        - title: logical metric name (e.g., "Profit")
        - series: unit/series (e.g., "USD", "units")
        - value: numeric value
        - iteration: optional tick/step number
        """
        try:
            self._logger.report_scalar(
                title=title, series=series, value=float(value), iteration=iteration
            )
        except Exception:
            pass

    def log_parameters(self, params: Dict[str, Any], name: str = "results") -> None:
        """
        Log a JSON-encoded blob of parameters/metrics as a text artifact for quick inspection.
        """
        try:
            payload = json.dumps(params or {}, default=str)
            self._logger.report_text(f"{name}: {payload}")
        except Exception:
            pass

    def upload_artifact(
        self, name: str, artifact_object: Any = None, path: Optional[str] = None
    ) -> None:
        """
        Upload an artifact by object or path.
        - If both provided, artifact_object takes precedence.
        """
        try:
            if hasattr(self._task, "upload_artifact"):
                if artifact_object is not None:
                    self._task.upload_artifact(name, artifact_object=artifact_object)
                elif path:
                    self._task.upload_artifact(name, artifact_object=path)
        except Exception:
            pass

    def execute_remotely(
        self, queue_name: str = "default", clone: bool = False, exit_process: bool = True
    ) -> None:
        """
        Request ClearML-Agent to execute this task remotely.
        - queue_name: target ClearML queue
        - clone: whether to clone the task before enqueueing (usually False for current task)
        - exit_process: if True, terminates local process after scheduling; the agent will rerun
        """
        try:
            if self._enabled and hasattr(self._task, "execute_remotely"):
                # ClearML SDK will re-launch the code on agent; local process exits if exit_process=True
                self._task.execute_remotely(
                    queue_name=queue_name, clone=clone, exit_process=exit_process
                )
        except Exception:
            # Never break caller code if ClearML is misconfigured
            pass

    def close(self) -> None:
        try:
            self._task.close()
        except Exception:
            pass


__all__ = ["ClearMLTracker"]
