from dataclasses import dataclass
from typing import Any, Dict, Optional

from fba_events.bus import EventBus
from fba_events.customer import CustomerDisputeEvent, DisputeResolvedEvent
from fba_events.sales import SaleOccurred
from services.world_store import WorldStore


@dataclass
class ReputationEvent:
    """
    Represents an event that affects customer reputation.

    This class is used by tests to simulate various reputation-impacting events.

    Attributes:
        customer_id (str): The ID of the customer.
        type (str): The type of event (e.g., "positive_review", "policy_violation").
        severity (str): The severity of the event ("low", "medium", "high").
        weight (float): Optional weight multiplier for the event impact.
        current_score (float): The current reputation score before this event.
        metadata (Optional[Dict[str, Any]]): Additional metadata about the event.
    """

    customer_id: str
    type: str
    severity: str = "medium"
    weight: float = 1.0
    current_score: float = 75.0
    metadata: Optional[Dict[str, Any]] = None


class CustomerReputationService:
    """
    Manages and calculates the customer reputation score.

    The reputation score is a value between 0 and 100, influencing customer
    purchasing decisions in the MarketSimulator.
    - Starts at a baseline of 75.
    - Increases slightly with every successful sale.
    - Decreases with customer disputes.
    - Decreases significantly if a dispute is resolved in the customer's favor.
    """

    INITIAL_REPUTATION = 75.0
    SALE_REPUTATION_GAIN = 0.1
    DISPUTE_REPUTATION_LOSS = -2.0
    DISPUTE_LOST_REPUTATION_LOSS = -5.0

    def __init__(self, event_bus: EventBus, world_store: WorldStore):
        self.event_bus = event_bus
        self.world_store = world_store
        # Initialize reputation in the world state
        self.world_store.set("customer_reputation", self.INITIAL_REPUTATION)

        self.event_bus.subscribe(SaleOccurred, self.on_sale)
        self.event_bus.subscribe(CustomerDisputeEvent, self.on_dispute)
        self.event_bus.subscribe(DisputeResolvedEvent, self.on_dispute_resolved)

    def _update_reputation(self, change: float):
        current_reputation = self.world_store.get("customer_reputation", self.INITIAL_REPUTATION)
        new_reputation = max(0, min(100, current_reputation + change))
        self.world_store.set("customer_reputation", new_reputation)

    def on_sale(self, event: SaleOccurred):
        """Called when a sale occurs."""
        self._update_reputation(self.SALE_REPUTATION_GAIN)

    def on_dispute(self, event: CustomerDisputeEvent):
        """Called when a customer raises a dispute."""
        self._update_reputation(self.DISPUTE_REPUTATION_LOSS)

    def on_dispute_resolved(self, event: DisputeResolvedEvent):
        """Called when a dispute is resolved."""
        if event.resolved_for_customer:
            self._update_reputation(self.DISPUTE_LOST_REPUTATION_LOSS)
        else:
            self._update_reputation(self.DISPUTE_REPUTATION_LOSS * 0.5)  # Smaller gain for winning

    def update_reputation_score(self, event: ReputationEvent) -> float:
        """
        Updates the reputation score based on a ReputationEvent.

        This method is used primarily for testing purposes to simulate various
        reputation-impacting events.

        Args:
            event: The ReputationEvent containing details about the reputation change.

        Returns:
            The new reputation score after applying the event.
        """
        # Define impact values for different event types
        impact_map = {
            "positive_review": {"low": 0.5, "medium": 1.0, "high": 2.0},
            "negative_review": {"low": -0.5, "medium": -1.5, "high": -3.0},
            "policy_violation": {"low": -1.0, "medium": -2.0, "high": -4.0},
            "sale_success": {"low": 0.1, "medium": 0.3, "high": 0.5},
            "dispute_approved": {"low": -0.5, "medium": -1.0, "high": -2.0},
            "dispute_denied": {"low": 0.5, "medium": 1.0, "high": 2.0},
            "dispute_escalated": {"low": -0.5, "medium": -1.0, "high": -2.0},
            "late_shipping": {"low": -0.5, "medium": -1.0, "high": -2.0},
            "return": {"low": -0.3, "medium": -0.7, "high": -1.0},
        }

        # Get the impact for this event type and severity
        if event.type in impact_map and event.severity in impact_map[event.type]:
            impact = impact_map[event.type][event.severity] * event.weight
        else:
            # Unknown event type or severity, no impact
            impact = 0.0

        # Apply the impact to the current score
        new_score = event.current_score + impact

        # Ensure the score is within bounds [0, 100]
        new_score = max(0.0, min(100.0, new_score))

        # Update the world store with the new score
        self.world_store.set("customer_reputation", new_score)

        return new_score
