"""
Core data models for the FBA Benchmark API.

This module defines Pydantic models used throughout the API for request/response
validation, serialization, and database interaction.
"""

from datetime import datetime, timezone
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, field_validator, model_validator


class ExperimentStatus(str, Enum):
    """Status of an experiment in the system."""

    CREATED = "created"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    STOPPED = "stopped"
    TIMEOUT = "timeout"


class BenchmarkStatus(str, Enum):
    """Status of a benchmark run."""

    CREATED = "created"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    STOPPED = "stopped"
    TIMEOUT = "timeout"
    NOT_FOUND = "not_found"


class AgentConfig(BaseModel):
    """Configuration for an agent in a benchmark."""

    agent_id: str
    framework: str
    enabled: bool = True
    config: Dict[str, Any] = Field(default_factory=dict)

    class Config:
        extra = "forbid"


class ScenarioConfig(BaseModel):
    """Configuration for a scenario in a benchmark."""

    name: str
    description: str
    domain: str
    duration_ticks: int
    scenario_type: str
    enabled: bool = True
    parameters: Dict[str, Any] = Field(default_factory=dict)
    agents: Optional[List[AgentConfig]] = None

    class Config:
        extra = "forbid"


class BenchmarkConfig(BaseModel):
    """Configuration for a benchmark run."""

    name: str
    description: Optional[str] = None
    scenarios: List[ScenarioConfig]
    agents: List[AgentConfig]
    metrics: Dict[str, Any] = Field(default_factory=dict)
    services: Dict[str, Any] = Field(default_factory=dict)

    class Config:
        extra = "forbid"


class MetricResult(BaseModel):
    """Result of a metric calculation."""

    name: str
    value: float
    unit: Optional[str] = None
    metadata: Dict[str, Any] = Field(default_factory=dict)


class AgentRunResult(BaseModel):
    """Result of a single agent run in a scenario."""

    agent_id: str
    run_number: int
    status: str
    metrics: Dict[str, Any] = Field(default_factory=dict)
    execution_time: float
    errors: List[str] = Field(default_factory=list)
    warnings: List[str] = Field(default_factory=list)

    class Config:
        extra = "forbid"


class ScenarioResult(BaseModel):
    """Result of a scenario execution."""

    scenario_name: str
    scenario_type: str
    status: str
    success: bool = True
    message: str = ""
    metrics: Dict[str, Any] = Field(default_factory=dict)
    agent_run_results: List[AgentRunResult] = Field(default_factory=list)
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None
    duration_seconds: Optional[float] = None

    def get_agent_results(self, agent_id: str) -> Optional[Dict[str, Any]]:
        """
        Retrieve results for a specific agent from the scenario metrics.

        Args:
            agent_id: The identifier of the agent to retrieve results for

        Returns:
            Dictionary containing the agent's results or None if not found
        """
        if isinstance(self.metrics, dict) and agent_id in self.metrics:
            return self.metrics[agent_id]
        return None

    class Config:
        extra = "forbid"


class BenchmarkResult(BaseModel):
    """Result of a benchmark execution."""

    benchmark_id: str
    run_id: str
    status: BenchmarkStatus
    config: Dict[str, Any]
    scenario_results: List[ScenarioResult] = Field(default_factory=list)
    overall_kpis: Dict[str, Any] = Field(default_factory=dict)
    overall_score: float = 0.0
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None
    duration_seconds: Optional[float] = None
    errors: List[str] = Field(default_factory=list)
    warnings: List[str] = Field(default_factory=list)
    metadata: Dict[str, Any] = Field(default_factory=dict)

    class Config:
        extra = "forbid"


class Experiment(BaseModel):
    """Experiment model for tracking benchmark experiments."""

    id: str
    name: str
    description: Optional[str] = None
    status: ExperimentStatus = ExperimentStatus.CREATED
    config: BenchmarkConfig
    results: Optional[List[BenchmarkResult]] = None
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: Optional[datetime] = None
    metadata: Dict[str, Any] = Field(default_factory=dict)

    @model_validator(mode="after")
    def _set_updated_at(self):
        if self.updated_at is None:
            self.updated_at = self.created_at
        return self

    class Config:
        extra = "forbid"


class BenchmarkCreateRequest(BaseModel):
    """Request model for creating a new benchmark."""

    config: BenchmarkConfig
    experiment_id: Optional[str] = None

    class Config:
        extra = "forbid"


class BenchmarkResponse(BaseModel):
    """Response model for benchmark operations."""

    benchmark_id: str
    status: BenchmarkStatus
    message: str
    result: Optional[BenchmarkResult] = None

    class Config:
        extra = "forbid"


class ExperimentCreateRequest(BaseModel):
    """Request model for creating a new experiment."""

    name: str
    description: Optional[str] = None
    config: BenchmarkConfig

    class Config:
        extra = "forbid"


class ExperimentResponse(BaseModel):
    """Response model for experiment operations."""

    id: str
    name: str
    status: ExperimentStatus
    message: str
    experiment: Optional[Experiment] = None

    class Config:
        extra = "forbid"


class HealthResponse(BaseModel):
    """Response model for health check endpoint."""

    status: str
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    version: str
    services: Dict[str, str] = Field(default_factory=dict)

    class Config:
        extra = "forbid"


class ErrorResponse(BaseModel):
    """Standard error response model."""

    error: str
    message: str
    details: Optional[Dict[str, Any]] = None
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

    class Config:
        extra = "forbid"
