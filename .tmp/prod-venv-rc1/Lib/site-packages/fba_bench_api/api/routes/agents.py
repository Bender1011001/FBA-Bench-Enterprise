from __future__ import annotations

import logging
import os
from datetime import datetime, timezone
from typing import Any, Dict, List, Literal, Optional

import yaml
from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel, Field, SecretStr, field_validator, ConfigDict
from sqlalchemy.ext.asyncio import AsyncSession

from benchmarking.config.pydantic_config import UnifiedAgentRunnerConfig
from fba_bench_api.core.database_async import get_async_db_session
from fba_bench_api.core.persistence_async import AsyncPersistenceManager
from fba_bench_api.models.agents import (
    AgentConfigurationResponse,
    AgentValidationRequest,
    AgentValidationResponse,
    FrameworksResponse,
)

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/api/v1/agents", tags=["Agents"])


def get_framework_examples() -> Dict[str, Dict[str, str]]:
    return {
        "diy": {
            "basic_agent": "Basic DIY agent with simple decision making",
            "advanced_agent": "Advanced DIY agent with complex strategies",
            "hybrid_agent": "Hybrid agent combining multiple approaches",
        },
        "crewai": {
            "standard_crew": "Standard CrewAI team with specialized agents",
            "hierarchical_crew": "Hierarchical CrewAI with manager-worker structure",
            "collaborative_crew": "Collaborative CrewAI with equal decision making",
        },
        "langchain": {
            "react_agent": "LangChain ReAct agent for reasoning and acting",
            "plan_execute_agent": "LangChain Plan-and-Execute agent for complex tasks",
            "conversational_agent": "LangChain Conversational agent for dialogue",
        },
    }


@router.get("/frameworks", response_model=FrameworksResponse)
async def list_frameworks():
    return FrameworksResponse(frameworks=["diy", "crewai", "langchain"])


@router.get("/available", response_model=List[AgentConfigurationResponse])
async def list_available_agents():
    out: List[AgentConfigurationResponse] = []
    for framework, kinds in get_framework_examples().items():
        for agent_type, description in kinds.items():
            # The example_config here provides a structural example, not mock data.
            # Removing "example only" to reflect that this is a valid structure.
            example = {
                "framework": framework,
                "agent_type": agent_type,
                "note": "Illustrative configuration structure",
            }
            out.append(
                AgentConfigurationResponse(
                    agent_framework=framework,
                    agent_type=agent_type,
                    description=description,
                    example_config=example,
                )
            )
    return out


@router.get("/bots", response_model=List[Dict[str, Any]])
async def list_baseline_bots():
    base: List[Dict[str, Any]] = []
    bot_dir = "baseline_bots/configs"
    if os.path.exists(bot_dir):
        for fn in os.listdir(bot_dir):
            if not fn.endswith((".yaml", ".yml")):
                continue
            name = fn.rsplit(".", 1)[0]
            try:
                with open(os.path.join(bot_dir, fn)) as f:
                    cfg = yaml.safe_load(f)
                base.append(
                    {
                        "bot_name": name,
                        "config_file": fn,
                        "description": cfg.get("description", f"Baseline bot: {name}"),
                        "model": cfg.get("model", "Unknown"),
                        "provider": cfg.get("provider", "Unknown"),
                        "config": cfg,
                    }
                )
            except Exception as e:
                logger.warning("Could not load bot config %s: %s", fn, e)
                base.append(
                    {
                        "bot_name": name,
                        "config_file": fn,
                        "description": f"Baseline bot: {name} (config load error)",
                        "error": str(e),
                    }
                )
    return base


@router.post("/validate", response_model=AgentValidationResponse)
async def validate_agent_configuration(req: AgentValidationRequest):
    cfg: UnifiedAgentRunnerConfig = req.agent_config
    errors: List[str] = []
    details: Dict[str, Any] = {}
    if not cfg.framework or cfg.framework not in {"diy", "crewai", "langchain"}:
        errors.append(f"Unsupported or missing framework: {cfg.framework!r}")
    if not cfg.agent_id:
        errors.append("Agent ID is required")

    if cfg.framework in {"crewai", "langchain"}:
        api_key_value_str = None
        is_api_key_valid = True

        if cfg.llm_config and cfg.llm_config.api_key:
            try:
                api_key_secret = cfg.llm_config.api_key
                if isinstance(api_key_secret, SecretStr):
                    api_key_value_str = api_key_secret.get_secret_value()
                else:
                    api_key_value_str = str(api_key_secret)

                if not api_key_value_str or api_key_value_str == "your_api_key_here":
                    is_api_key_valid = False
                    errors.append("API key is missing or is a placeholder.")
                    details["api_key"] = "API key is missing or is a placeholder."
                else:
                    details["api_key_length"] = len(api_key_value_str)

            except Exception as e:
                logger.error(f"Error processing API key: {e}")
                is_api_key_valid = False
                errors.append("Error retrieving API key.")
                details["api_key"] = "Error retrieving API key."

        elif not cfg.llm_config or not cfg.llm_config.api_key:
            is_api_key_valid = False
            errors.append("llm_config or api_key is missing.")
            details["api_key"] = "llm_config or api_key is missing."

        if not is_api_key_valid:
            pass
        if not cfg.llm_config or not cfg.llm_config.model:
            errors.append("Model name is required")
        if not cfg.llm_config or not cfg.llm_config.provider:
            errors.append("Provider is required")
    if (
        cfg.framework == "crewai"
        and cfg.crew_config
        and cfg.crew_config.crew_size
        and cfg.crew_config.crew_size < 1
    ):
        errors.append("Crew size must be at least 1")
    if cfg.framework == "langchain" and cfg.max_iterations and cfg.max_iterations < 1:
        errors.append("Max iterations must be at least 1")

    ok = not errors
    if ok:
        details["framework"] = cfg.framework
        details["agent_type"] = (
            getattr(cfg.agent_config, "agent_type", "unknown") if cfg.agent_config else "unknown"
        )
        msg = f"Agent configuration for {cfg.framework} is valid"
    else:
        msg = f"Agent configuration has {len(errors)} validation errors"
        details["errors"] = errors
    return AgentValidationResponse(is_valid=ok, message=msg, details=details)


# === CRUD Agent Management (in-memory repository, production-ready interface) ===


def get_pm(db: AsyncSession = Depends(get_async_db_session)) -> AsyncPersistenceManager:
    return AsyncPersistenceManager(db)


# Pydantic Schemas
FrameworkEnum = Literal["baseline", "langchain", "crewai", "custom"]


class AgentBase(BaseModel):
    name: str = Field(..., min_length=1, description="Human-readable agent name")
    framework: FrameworkEnum = Field(..., description="Agent framework")
    config: dict | None = Field(default=None, description="Framework-specific configuration")

    @field_validator("name")
    @classmethod
    def _validate_name(cls, v: str) -> str:
        if not v.strip():
            raise ValueError("name must be non-empty")
        return v.strip()


class AgentCreate(AgentBase):
    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "name": "My Agent",
                "framework": "baseline",
                "config": {"model": "gpt-4o-mini", "temperature": 0.2},
            }
        }
    )


class AgentUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=1)
    framework: Optional[FrameworkEnum] = None
    config: Optional[dict] = None

    @field_validator("name")
    @classmethod
    def _validate_name(cls, v: Optional[str]) -> Optional[str]:
        if v is not None and not v.strip():
            raise ValueError("name must be non-empty when provided")
        return v.strip() if v else v

    model_config = ConfigDict(
        json_schema_extra={"example": {"name": "Updated Agent", "config": {"temperature": 0.3}}}
    )


class Agent(AgentBase):
    id: str = Field(..., description="UUID4 identifier")
    created_at: datetime
    updated_at: datetime


# Utilities
import uuid as _uuid


def _uuid4() -> str:
    return str(_uuid.uuid4())


def _now() -> datetime:
    return datetime.now(timezone.utc)


# CRUD Endpoints


@router.get("", response_model=list[Agent], description="List all agents")
async def list_agents(pm: AsyncPersistenceManager = Depends(get_pm)):
    items = await pm.agents().list()
    return [Agent(**i) for i in items]


@router.post(
    "", response_model=Agent, status_code=status.HTTP_201_CREATED, description="Create a new agent"
)
async def create_agent(payload: AgentCreate, pm: AsyncPersistenceManager = Depends(get_pm)):
    data = payload.model_dump()
    item = {
        "id": _uuid4(),
        "name": data["name"],
        "framework": data["framework"],
        "config": data.get("config") or {},
        "created_at": _now(),
        "updated_at": _now(),
    }
    created = await pm.agents().create(item)
    return Agent(**created)


@router.get("/{agent_id}", response_model=Agent, description="Retrieve an agent by id")
async def get_agent(agent_id: str, pm: AsyncPersistenceManager = Depends(get_pm)):
    item = await pm.agents().get(agent_id)
    if not item:
        raise HTTPException(status.HTTP_404_NOT_FOUND, f"Agent '{agent_id}' not found")
    return Agent(**item)


@router.patch("/{agent_id}", response_model=Agent, description="Update an existing agent")
async def update_agent(
    agent_id: str, payload: AgentUpdate, pm: AsyncPersistenceManager = Depends(get_pm)
):
    # Validate framework transitions are within enum (handled by pydantic)
    current = await pm.agents().get(agent_id)
    if not current:
        raise HTTPException(status.HTTP_404_NOT_FOUND, f"Agent '{agent_id}' not found")
    update_data = payload.model_dump(exclude_unset=True)
    update_data["updated_at"] = _now()
    updated = await pm.agents().update(agent_id, update_data)
    return Agent(**updated)  # type: ignore[arg-type]


@router.delete("/{agent_id}", status_code=status.HTTP_204_NO_CONTENT, description="Delete an agent")
async def delete_agent(agent_id: str, pm: AsyncPersistenceManager = Depends(get_pm)):
    ok = await pm.agents().delete(agent_id)
    if not ok:
        raise HTTPException(status.HTTP_404_NOT_FOUND, f"Agent '{agent_id}' not found")
    return None
